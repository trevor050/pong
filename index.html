<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Pong Wars</title>
  <meta name="description" content="Dynamic Pong Wars – a colorful pong game where balls conquer opposing territory.">
  <meta name="author" content="Marko Denic">
  <meta name="theme-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta property="og:title" content="Dynamic Pong Wars">
  <meta property="og:description" content="Play Dynamic Pong Wars – conquer the grid with your balls in a colorful pong battle.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://markodenic.tech">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dynamic Pong Wars">
  <meta name="twitter:description" content="Play Dynamic Pong Wars – conquer the grid with your balls in a colorful pong battle.">

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      background: linear-gradient(to bottom, #000000 0%, #FFFFFF 100%);
    }

    main {
      flex: 1;
      max-width: 600px;
      margin: 0 auto;
      padding: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    #resetBtn, #playPauseBtn, #configBtn {
      position: fixed;
      top: 20px;
      width: 50px;
      height: 50px;
      background: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      cursor: pointer;
      z-index: 1000;
      transition: background 0.2s, transform 0.15s ease;
    }

    #resetBtn { right: 140px; }
    #playPauseBtn { right: 80px; }
    #configBtn { right: 20px; }

    #resetBtn:active, #playPauseBtn:active, #configBtn:active {
      transform: scale(0.97);
    }

    #resetBtn svg, #playPauseBtn svg, #configBtn svg {
      stroke: #000;
      width: 30px;
      height: 30px;
      fill: none;
    }

    #configPanel {
      position: fixed;
      top: 10px;
      right: -280px;
      width: 220px;
      background: #fff;
      padding: 75px 25px 25px;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 999;
      transition: right 0.18s ease-out;
    }

    #configPanel.visible { right: 10px; }

    #configPanel label {
      display: flex;
      flex-direction: column;
      gap: 10px;
      justify-content: space-between;
    }

    canvas {
      width: 100%;
      margin-top: auto;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      display: block;
    }

    #scoreDisplay {
      padding: 15px;
      font-size: 16px;
      color: white;
      background: black;
      border-bottom-left-radius: 6px;
      border-bottom-right-radius: 6px;
      display: inline-block;
    }

    footer {
      padding: 15px;
      background: #000;
      color: #fff;
      text-align: center;
      font-size: 14px;
    }

    footer a { color: #ffc600; }
  </style>
</head>
<body>
<div id="resetBtn">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 12v-3a3 3 0 0 1 3 -3h13m-3 -3l3 3l-3 3"/>
    <path d="M20 12v3a3 3 0 0 1 -3 3h-13m3 3l-3 -3l3 -3"/>
  </svg>
</div>

<div id="playPauseBtn" data-playing="true">
  <svg class="play-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 4v16l13 -8z" />
  </svg>
  <svg class="pause-icon" style="display: block;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M6 5h4v14h-4z m8 0h4v14h-4z"/>
  </svg>
</div>

<div id="configBtn">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z"/>
    <path d="M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/>
  </svg>
</div>

<div id="configPanel">
  <label>
    Day color:
    <input type="color" id="dayColorInput" value="#FFFFFF"/>
  </label>
  <label>
    Night color:
    <input type="color" id="nightColorInput" value="#000000"/>
  </label>
</div>

<main>
  <div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div id="scoreDisplay"></div>
  </div>
</main>

<footer>
  Made by <a href="https://markodenic.tech" target="_blank">Marko Denic</a>. Source on
  <a href="https://github.com/markodenic/dynamic-pong-wars" target="_blank">GitHub</a>. Inspired by
  <a href="https://github.com/vnglst/pong-wars" target="_blank">Pong Wars</a>.
</footer>

<script>
  const canvas = document.querySelector("#gameCanvas");
  const ctx = canvas.getContext("2d");
  const scoreDisplay = document.querySelector("#scoreDisplay");
  const dayColorInput = document.querySelector("#dayColorInput");
  const nightColorInput = document.querySelector("#nightColorInput");
  const configBtn = document.querySelector("#configBtn");
  const configPanel = document.querySelector("#configPanel");
  const resetBtn = document.querySelector("#resetBtn");
  const playPauseBtn = document.querySelector("#playPauseBtn");
  const playIcon = playPauseBtn.querySelector(".play-icon");
  const pauseIcon = playPauseBtn.querySelector(".pause-icon");

  const TILE_SIZE = 25;
  const MAX_SPEED = 10;
  const MIN_SPEED = 5;
  const ACCELERATION = 0.1;

  let dayColor = "#FFFFFF";
  let nightColor = "#000000";
  let dayScore = 0;
  let nightScore = 0;
  let iteration = 0;
  let isPlaying = true;
  let animationFrameId = null;

  const gridWidth = canvas.width / TILE_SIZE;
  const gridHeight = canvas.height / TILE_SIZE;

  const ownership = new Array(gridWidth * gridHeight).fill(0).map((_, idx) =>
                                                                      idx % gridWidth < gridWidth / 2 ? 0 : 1
  );

  const grid = new Array(gridWidth * gridHeight).fill(0).map((_, idx) => ({
    x: (idx % gridWidth) * TILE_SIZE,
    y: Math.floor(idx / gridWidth) * TILE_SIZE,
    get color() {
      return ownership[idx] === 0 ? dayColor : nightColor;
    }
  }));

  const balls = [
    {
      x: canvas.width / 4,
      y: canvas.height / 2,
      vx: 8,
      vy: -8,
      get color() { return nightColor; },
      get targetColor() { return dayColor; }
    },
    {
      x: (canvas.width / 4) * 3,
      y: canvas.height / 2,
      vx: -8,
      vy: 8,
      get color() { return dayColor; },
      get targetColor() { return nightColor; }
    }
  ];

  function toggleConfigPanel() {
    configPanel.classList.toggle("visible");
  }

  function togglePlayPause() {
    isPlaying = !isPlaying;
    playIcon.style.display = isPlaying ? "none" : "block";
    pauseIcon.style.display = isPlaying ? "block" : "none";
    playPauseBtn.dataset.playing = isPlaying;
    if (isPlaying) {
      animationFrameId = requestAnimationFrame(render);
    } else {
      cancelAnimationFrame(animationFrameId);
    }
  }

  function updateBackground() {
    document.body.style.background = `linear-gradient(to bottom, ${nightColor} 0%, ${dayColor} 100%)`;
  }

  function drawTile(tile) {
    ctx.fillStyle = tile.color;
    ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
  }

  function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, TILE_SIZE / 2, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.closePath();
  }

  function detectCollision(ball) {
    const ballRect = {
      left: ball.x - TILE_SIZE / 2,
      right: ball.x + TILE_SIZE / 2,
      top: ball.y - TILE_SIZE / 2,
      bottom: ball.y + TILE_SIZE / 2
    };
    grid.forEach((tile, idx) => {
      const tileRect = {
        left: tile.x,
        right: tile.x + TILE_SIZE,
        top: tile.y,
        bottom: tile.y + TILE_SIZE
      };
      if (
          ballRect.right > tileRect.left &&
          ballRect.left < tileRect.right &&
          ballRect.bottom > tileRect.top &&
          ballRect.top < tileRect.bottom &&
          ownership[idx] !== (ball === balls[0] ? 0 : 1)
      ) {
        ownership[idx] = ball === balls[0] ? 0 : 1;
        const dx = ball.x - (tile.x + TILE_SIZE / 2);
        const dy = ball.y - (tile.y + TILE_SIZE / 2);
        if (Math.abs(dx) > Math.abs(dy)) {
          ball.vx = -ball.vx;
        } else {
          ball.vy = -ball.vy;
        }
      }
    });
  }

  function checkBoundaries(ball) {
    if (ball.x < TILE_SIZE / 2 || ball.x > canvas.width - TILE_SIZE / 2) {
      ball.vx = -ball.vx;
      ball.x = Math.max(TILE_SIZE / 2, Math.min(canvas.width - TILE_SIZE / 2, ball.x));
    }
    if (ball.y < TILE_SIZE / 2 || ball.y > canvas.height - TILE_SIZE / 2) {
      ball.vy = -ball.vy;
      ball.y = Math.max(TILE_SIZE / 2, Math.min(canvas.height - TILE_SIZE / 2, ball.y));
    }
  }

  function updateBall(ball) {
    ball.vx += (Math.random() - 0.5) * ACCELERATION;
    ball.vy += (Math.random() - 0.5) * ACCELERATION;
    const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);
    if (speed > MAX_SPEED) {
      const scale = MAX_SPEED / speed;
      ball.vx *= scale;
      ball.vy *= scale;
    }
    if (speed < MIN_SPEED) {
      const scale = MIN_SPEED / speed;
      ball.vx *= scale;
      ball.vy *= scale;
    }
    ball.x += ball.vx;
    ball.y += ball.vy;
  }

  function resetGame() {
    ownership.forEach((_, idx) => {
      ownership[idx] = idx % gridWidth < gridWidth / 2 ? 0 : 1;
    });
    balls[0].x = canvas.width / 4;
    balls[0].y = canvas.height / 2;
    balls[0].vx = 8;
    balls[0].vy = -8;
    balls[1].x = (canvas.width / 4) * 3;
    balls[1].y = canvas.height / 2;
    balls[1].vx = -8;
    balls[1].vy = 8;
    iteration = 0;
    if (!isPlaying) togglePlayPause();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    dayScore = 0;
    nightScore = 0;
    grid.forEach((tile, idx) => {
      drawTile(tile);
      if (ownership[idx] === 0) dayScore++;
      if (ownership[idx] === 1) nightScore++;
    });
    scoreDisplay.textContent = `Day: ${dayScore} | Night: ${nightScore}`;
    balls.forEach(ball => {
      drawBall(ball);
      detectCollision(ball);
      checkBoundaries(ball);
      updateBall(ball);
    });
    iteration++;
    if (iteration % 1000 === 0) console.log("Iteration:", iteration);
    if (isPlaying) {
      animationFrameId = requestAnimationFrame(render);
    }
  }

  function updateAllColors() {
    balls[0].color = nightColor;
    balls[1].color = dayColor;
    updateBackground();
  }

  function handleDayColorChange(e) {
    dayColor = e.target.value;
    updateAllColors();
  }

  function handleNightColorChange(e) {
    nightColor = e.target.value;
    updateAllColors();
  }

  configBtn.addEventListener("click", toggleConfigPanel);
  resetBtn.addEventListener("click", resetGame);
  playPauseBtn.addEventListener("click", togglePlayPause);
  dayColorInput.addEventListener("input", handleDayColorChange);
  nightColorInput.addEventListener("input", handleNightColorChange);

  updateBackground();
  animationFrameId = requestAnimationFrame(render);
</script>
</body>
</html>
